// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    HELLO_GUEST_ELF, HELLO_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
//use serde::{Deserialize, Serialize};
//use risc0_zkvm::serde::from_slice;
use tfhe::core_crypto::entities::*;
use tfhe::core_crypto::commons::parameters::*;
use tfhe::core_crypto::algorithms::*;
//use tfhe::core_crypto::commons::ciphertext_modulus::*;
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> { 
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();
    //let ciphertext_modulus = CiphertextModulus::try_new(18446744069414584321).unwrap();
    let ciphertext_modulus = CiphertextModulus::try_new((1 << 64) - (1 << 32) + 1).unwrap();

    
    let std_bootstrapping_key = LweBootstrapKeyOwned::new(
        0u64,
        GlweSize(2),
        PolynomialSize(16),
        DecompositionBaseLog(23),
        DecompositionLevelCount(1),
        LweDimension(1),
        ciphertext_modulus
    );
    println!("std_bootstrapping_key: {:?}", std_bootstrapping_key);
    
    
    let std_bootstrapping_key = LweBootstrapKeyOwned::from_container(
        vec![
            2033395872941264785, 1837508328875066560, 17274602760746865264, 95594919683455582, 
            7481326429170359781, 1090958616442999126, 6629424611194235550, 12472579667288967600, 
            2727698786823141840, 4994519625942561957, 16617463827031595086, 8364881689211492839, 
            15110017345629475492, 17947844274005057801, 5586119338161658349, 6300217321366673504, 
            5791704444701164600, 695279297183743575, 12825142619777430212, 8510025897790893345, 
            6129519673147995174, 11772334407825058122, 11666697847923637219, 10201628897552751028, 
            14469708624659724251, 10740948697928134656, 5753473924154150581, 11102608092916030605, 
            14580216733407842999, 9027031126545250883, 17753319469587595288, 13609377640708803752, 
            8644372503114896791, 3543447346613273150, 10481513084331923549, 17139603923805514239, 
            3921284787284597517, 9016539021942199508, 6956238148740761630, 4887076230884755369, 
            2756719265394600697, 13171278186856243594, 8565926532646833771, 15822238750590672059, 
            9199686639547254809, 12202844521617298389, 9934831137717267442, 7696949756186456984, 
            5685708018978083733, 16183890585618272644, 5412452772764403757, 14341199217776804726, 
            8251676614263867343, 13151757995096969700, 1708996736879395450, 9258672939776549508, 
            1280854444288987504, 1229985850836635216, 2884208328327932670, 15056048231760058983, 
            5239532222587081148, 7338083930576758656, 14051782717352166574, 1411776197802022974
        ],
        GlweSize(2),
        PolynomialSize(16),
        DecompositionBaseLog(23),
        DecompositionLevelCount(1),
        ciphertext_modulus
    );
    println!("std_bootstrapping_key: {:?}", std_bootstrapping_key);
    
    let mut ntt_bsk = NttLweBootstrapKeyOwned::new (
            0u64,
            LweDimension(1),
            GlweSize(2), 
            PolynomialSize(16),  
            DecompositionBaseLog(23), 
            DecompositionLevelCount(1), 
            ciphertext_modulus,
    );
    println!("ntt_bsk: {:?}", ntt_bsk);

    /*
    let ntt_bsk = NttLweBootstrapKeyOwned::from_container(
        vec![
            0u64, 0, 0, 0,
             0, 0, 0, 0,
              0, 0, 0, 0,
               0, 0, 0, 0,
                0, 0, 0, 0,
                 0, 0, 0, 0,
                  0, 0, 0, 0,
                   0, 0, 0, 0,
                    0, 0, 0, 0,
                     0, 0, 0, 0,
                      0, 0, 0, 0,
                       0, 0, 0, 0,
                        0, 0, 0, 0,
                         0, 0, 0, 0,
                          0, 0, 0, 0,
                           0, 0, 0, 0,
            ],
        GlweSize(2), 
        PolynomialSize(16),  
        DecompositionBaseLog(23), 
        DecompositionLevelCount(1), 
        ciphertext_modulus,
    );
    */

    let lwe_ciphertext_in = LweCiphertextOwned::new(
        0u64,
        LweSize(2),
        ciphertext_modulus,
    );

    let lwe_ciphertext_in = LweCiphertextOwned::from_container(
        vec![523972077917885079, 1729419507372829432],
        ciphertext_modulus,
    );

    let mut accumulator = GlweCiphertextOwned::new(
        0u64, 
        GlweSize(2),
        PolynomialSize(16), 
        ciphertext_modulus
    );

    let mut accumulator = GlweCiphertextOwned::from_container(
        vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
            1152921504606846976, 2305843009213693952, 3458764513820540928, 4611686018427387904,
            5764607523034234880, 6917529027641081856, 8070450532247928832, 9223372036854775808, 
            10376293541461622784, 11529215046068469760, 12682136550675316736, 13835058055282163712, 
            14987979559889010688, 16140901064495857664, 17293822569102704640
         ],
        PolynomialSize(16),
        ciphertext_modulus
    );

    let mut pbs_multiplication_ct = LweCiphertextOwned::new(
        0u64,
        LweSize(17),
        ciphertext_modulus,
    );

    /* hopefully there is not a reference back to the accumulator in any way, and it is just a vector.
    let mut accumulator: GlweCiphertextOwned<u64> = generate_programmable_bootstrap_glwe_lut(
        polynomial_size,
        glwe_dimension.to_glwe_size(),
        message_modulus as usize,
        ciphertext_modulus,
        delta,
        |x: u64| 2 * x,
    );
    */

    
    let input_data = bincode::serialize(&std_bootstrapping_key)?;
    let result_in: LweBootstrapKeyOwned<u64> = bincode::deserialize(&input_data)?;
    println!("std_bootstrapping_key: {:?}", result_in);

    let input_data_2 = bincode::serialize(&ntt_bsk)?;
    let result_in_2: NttLweBootstrapKeyOwned<u64> = bincode::deserialize(&input_data_2)?;
    println!("ntt_bsk_bf: {:?}", result_in_2);

    let input_data_3 = bincode::serialize(&lwe_ciphertext_in)?;
    let result_in_3: LweCiphertextOwned<u64> = bincode::deserialize(&input_data_3)?;
    println!("lwe_ciphertext_in: {:?}", result_in_3);

    let input_data_4 = bincode::serialize(&accumulator)?;
    let result_in_4: GlweCiphertextOwned<u64> = bincode::deserialize(&input_data_4)?;
    println!("accumulator_bf: {:?}", result_in_4);

    let input_data_5 = bincode::serialize(&pbs_multiplication_ct)?;
    let result_in_5: LweCiphertextOwned<u64> = bincode::deserialize(&input_data_5)?;
    

    par_convert_standard_lwe_bootstrap_key_to_ntt64(&std_bootstrapping_key, &mut ntt_bsk);
    println!("ntt_bsk_af: {:?}", ntt_bsk);

    blind_rotate_ntt64_assign(&lwe_ciphertext_in, &mut accumulator, &ntt_bsk);
    println!("accumulator_af: {:?}", accumulator);

    extract_lwe_sample_from_glwe_ciphertext(
        &accumulator,
        &mut pbs_multiplication_ct,
        MonomialDegree(0),
    );
    println!("pbs_output: {:?}", pbs_multiplication_ct);
    
    let env = ExecutorEnv::builder()
        .write(&input_data)
        .unwrap()
        .write(&input_data_2)
        .unwrap()
        .write(&input_data_3)
        .unwrap()
        .write(&input_data_4)
        .unwrap()
        .write(&input_data_5)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, HELLO_GUEST_ELF)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;
    //println!("receipt: {:?}", receipt);

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    //let output_data: NttLweBootstrapKey = bincode::deserialize(&receipt.journal.decode().unwrap());

    let output: LweCiphertextOwned<u64> = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("Hello, world! I generated a proof of guest execution! {:?} is a public output from journal ", output);

    receipt
        .verify(HELLO_GUEST_ID)
        .unwrap();

    Ok(())
}
